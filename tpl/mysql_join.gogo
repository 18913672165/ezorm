{{define "mysql_join"}}package {{.Package}}
import (
	"fmt"
	"strings"
	"bytes"
)

var (
	_ = fmt.Println
	_ = strings.Index
	_ bytes.Buffer
)

{{$obj := .}}
{{$baseType := printf "[]*%v" $obj.Name}}

{{$fields := $obj.GetJoinFields}}

{{range $field := $obj.GetJoinFields}}

func (m *_{{$obj.Name}}Mgr) To{{$field.Name}}(base {{$baseType}}) []{{$field.Type}} {
	ids := make([]{{$field.Type}}, len(base))
	for idx, b := range base {
		ids[idx] = b.{{$field.Name}}
	}
	return ids
}

func (m *_{{$obj.Name}}Mgr) To{{$field.Name}}Query(base {{$baseType}}) string {
	 buf := bytes.NewBuffer(nil)
	 buf.WriteString("`{{camel2name $field.Name}}` IN (")
	 ids := m.To{{$field.Name}}Query(base)
	 for idx, n := range ids {
	 	 buf.WriteString(fmt.Sprint(n))
		 if idx == len(ids) - 1 {
		 		 break
		 }
		 buf.WriteString(",")
	 }
	 buf.WriteString(")")
	 return buf.String()
}

{{range $jk := $field.JoinKeys}}
{{$retType := printf "%v%v" $obj.Name $jk.Tbl}}

func (m *_{{$obj.Name}}Mgr) LeftJoin{{$jk.Tbl}}({{$field.ArgName}} []{{$field.Type}}) ([]*{{$jk.Tbl}}, error) {
	base := {{$field.ArgName}}
	targets, err := {{$jk.Tbl}}Mgr.FindIn{{$jk.Field}}(base)
	if err != nil {
	    return nil, err
	}
	refMap := make(map[{{$field.Type}}]*{{$jk.Tbl}}, len(targets))
	for _, t := range targets {
		refMap[t.{{$jk.Field}}] = t
	}

	ret := make([]*{{$jk.Tbl}}, len(base))
	for idx := range base {
		ret[idx] = refMap[base[idx]]
	}
	return ret, nil
}

{{end}}
{{end}}
{{end}}