{{define "mysql_group"}}package {{.Package}}

import (
	   "github.com/ezbuy/ezorm/db"
	   "fmt"
	   "bytes"
)

var (
	_ db.M
	_ = fmt.Println
	_ bytes.Buffer
)

{{$obj := .}}
{{$tag := printf "%s.%s" $obj.DbName $obj.Name}}
{{$tbl := printf "%s.%s" $obj.DbName (camel2name (strDefault $obj.Table $obj.Name))}}

{{range $gName, $gField := $obj.GroupBy}}
{{$hasagg := $gField.HasAggGroupFields}}
{{$gtype := printf "%vGroup%v" $obj.Name $gName}}

{{if $hasagg}}
type {{$gtype}} struct {
	{{- range $f := $gField.Fields -}}
	{{$f.Field}} []{{$f.FieldType}}
	{{ end }}
}
{{end}}


func (m *_{{$obj.Name}}Mgr) GroupBy{{$gName}}({{$gField.FromField.ArgName}} []{{$gField.FromField.Type}}, offset, limit int, sorts ...string) (results *{{$gtype}}, err error) {
	from := {{$gField.FromField.ArgName}}
	buf := bytes.NewBuffer(nil)
	buf.WriteString("SELECT {{join ($gField.GetGroupFieldProjection) "," -}}")
	buf.WriteString(" FROM {{$tbl}}")
	if from != nil {
	   buf.WriteString(" WHERE `{{camel2name $gField.FromField.Name}}` in ")
	   {{ toids "buf" $gField.FromField.Type "from" }}
	}
	buf.WriteString(" GROUP BY {{join ($gField.GetGroupFieldKey) "," }} ")
	buf.WriteString(m.getLimitQuery(offset, limit, sorts))

	rows, err := db.MysqlQuery(buf.String())
	if err != nil {
		return nil, fmt.Errorf("{{$tag}} query error: %v", err)
	}
	defer rows.Close()

	results = new({{$gtype}})
	for rows.Next() {
		var (
			{{- range $f := $gField.Fields -}}
			{{$f.Field}} {{$f.FieldType}}
			{{ end }}
		)
		err := rows.Scan(
		{{- range $field := $gField.Fields -}}
			&({{$field.Field}}),
		{{ end }}
		)
		if err != nil {
			return nil, err
		}

		{{ range $field := $gField.Fields -}}
		results.{{$field.Field}} = append(results.{{$field.Field}}, {{$field.Field}})
		{{ end }}
	}
	if err := rows.Err() ;err != nil {
		return nil, fmt.Errorf("{{$tag}} fetch result error: %v", err)
	}

	return

}

{{end}}
{{end}}